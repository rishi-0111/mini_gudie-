"""
STEP 9 — Generate Supabase Seed SQL
Exports top hidden gems to a seed SQL file for the places table.
Uses the CORRECT column names: category, images (TEXT[]), amenities (JSONB).
"""

import pandas as pd
import os
import json

DATA_DIR = r"d:\miniguide\hidden_gem_explorer\data"
OUT_DIR = r"d:\miniguide\supabase"


def escape_sql(s):
    if s is None:
        return ""
    return str(s).replace("'", "''").replace("\n", " ").strip()


def generate_seed_sql(top_n=500):
    df = pd.read_parquet(os.path.join(DATA_DIR, "final.parquet"))

    # Get top hidden gems by final_score
    hidden = df[df["hidden_label"] == 1].nlargest(top_n, "final_score")
    print(f"Generating SQL for top {len(hidden)} hidden gems...")

    lines = [
        "-- Hidden Gem Explorer: AI-detected hidden tourist spots in India",
        "-- Generated by hidden_gem_explorer/step9_seed.py",
        f"-- Total: {len(hidden)} hidden gems",
        "",
        "-- Ensure 'hidden_spot' exists in the category enum",
        "DO $$ BEGIN",
        "  IF NOT EXISTS (SELECT 1 FROM pg_enum WHERE enumlabel = 'hidden_spot'"
        " AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'place_category')) THEN",
        "    ALTER TYPE place_category ADD VALUE IF NOT EXISTS 'hidden_spot';",
        "  END IF;",
        "END $$;",
        "",
        "INSERT INTO places (name, description, latitude, longitude, category, "
        "images, rating, review_count, address, amenities, verified)",
        "VALUES",
    ]

    values = []
    for _, row in hidden.iterrows():
        name = escape_sql(row["name"])[:100]
        spot_type = escape_sql(row.get("type", "hidden_spot"))

        # Generate description
        desc_parts = [f"AI-detected hidden gem ({spot_type})"]
        if row.get("distance_from_major_city", 0) > 0:
            desc_parts.append(f"{row['distance_from_major_city']:.0f}km from nearest major city")
        if row.get("hidden_gem_score", 0) > 0:
            desc_parts.append(f"Hidden Gem Score: {row['hidden_gem_score']:.1f}/100")
        if row.get("ml_hidden_score", 0) > 0:
            desc_parts.append(f"ML confidence: {row['ml_hidden_score']:.0%}")

        description = escape_sql(". ".join(desc_parts))

        lat = round(row["lat"], 6)
        lon = round(row["lon"], 6)

        # Simulated rating (hidden gems: 3.5–4.8)
        rating = round(3.5 + (row.get("hidden_gem_score", 50) / 100) * 1.3, 1)
        rating = min(rating, 4.9)

        review_count = int(row.get("simulated_review_count", 0))

        # Amenities as JSONB
        amenities = {
            "type": spot_type,
            "hidden_gem_score": round(row.get("hidden_gem_score", 0), 1),
            "ml_hidden_score": round(row.get("ml_hidden_score", 0), 3),
            "final_score": round(row.get("final_score", 0), 1),
            "connectivity_score": round(row.get("connectivity_score", 0), 1),
            "hotel_count_3km": int(row.get("hotel_count", 0)),
            "bus_stops_2km": int(row.get("bus_stop_count", 0)),
            "metro_5km": int(row.get("metro_count", 0)),
            "distance_from_city_km": round(row.get("distance_from_major_city", 0), 1),
        }
        amenities_json = escape_sql(json.dumps(amenities))

        values.append(
            f"  ('{name}', '{description}', {lat}, {lon}, 'hidden_spot', "
            f"ARRAY[]::TEXT[], {rating}, {review_count}, '', "
            f"'{amenities_json}'::jsonb, false)"
        )

    lines.append(",\n".join(values) + ";")

    out_path = os.path.join(OUT_DIR, "seed_hidden_gems.sql")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    print(f"Saved {out_path} ({len(hidden)} rows)")
    return out_path


if __name__ == "__main__":
    generate_seed_sql()
